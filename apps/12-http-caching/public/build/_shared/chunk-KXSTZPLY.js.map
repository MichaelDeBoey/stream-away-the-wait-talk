{
  "version": 3,
  "sources": ["../../../app/utils.ts"],
  "sourcesContent": ["import { useMatches } from \"@remix-run/react\";\nimport { useMemo } from \"react\";\n\nimport type { User } from \"~/models/user.server\";\n\nconst DEFAULT_REDIRECT = \"/\";\n\n/**\n * This should be used any time the redirect path is user-provided\n * (Like the query string on our login/signup pages). This avoids\n * open-redirect vulnerabilities.\n * @param {string} to The redirect destination\n * @param {string} defaultRedirect The redirect to use if the to is unsafe.\n */\nexport function safeRedirect(\n  to: FormDataEntryValue | string | null | undefined,\n  defaultRedirect: string = DEFAULT_REDIRECT\n) {\n  if (!to || typeof to !== \"string\") {\n    return defaultRedirect;\n  }\n\n  if (!to.startsWith(\"/\") || to.startsWith(\"//\")) {\n    return defaultRedirect;\n  }\n\n  return to;\n}\n\n/**\n * This base hook is used in other hooks to quickly search for specific data\n * across all loader data using useMatches.\n * @param {string} id The route id\n * @returns {JSON|undefined} The router data or undefined if not found\n */\nexport function useMatchesData(\n  id: string\n): Record<string, unknown> | undefined {\n  const matchingRoutes = useMatches();\n  const route = useMemo(\n    () => matchingRoutes.find((route) => route.id === id),\n    [matchingRoutes, id]\n  );\n  return route?.data;\n}\n\nfunction isUser(user: any): user is User {\n  return user && typeof user === \"object\" && typeof user.email === \"string\";\n}\n\nexport function useOptionalUser(): User | undefined {\n  const data = useMatchesData(\"root\");\n  if (!data || !isUser(data.user)) {\n    return undefined;\n  }\n  return data.user;\n}\n\nexport function useUser(): User {\n  const maybeUser = useOptionalUser();\n  if (!maybeUser) {\n    throw new Error(\n      \"No user found in root loader, but user is required by useUser. If user is optional, try useOptionalUser instead.\"\n    );\n  }\n  return maybeUser;\n}\n\nexport function validateEmail(email: unknown): email is string {\n  return typeof email === \"string\" && email.length > 3 && email.includes(\"@\");\n}\n\nexport const currencyFormatter = new Intl.NumberFormat(\"en-US\", {\n  style: \"currency\",\n  currency: \"USD\",\n  maximumFractionDigits: 2,\n});\n\nexport function asUTC(date: Date) {\n  return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());\n}\n\nexport function parseDate(dateString: string) {\n  const [year, month, day] = dateString.split(\"-\").map(Number);\n  return asUTC(new Date(year, month - 1, day));\n}\n"],
  "mappings": ";;;;;;;AAAA;AACA,mBAAwB;AAuEjB,IAAM,oBAAoB,IAAI,KAAK,aAAa,SAAS;AAAA,EAC9D,OAAO;AAAA,EACP,UAAU;AAAA,EACV,uBAAuB;AAAA;AAGlB,eAAe,MAAY;AAChC,SAAO,IAAI,KAAK,KAAK,kBAAkB,KAAK,eAAe,KAAK;AAAA;AAG3D,mBAAmB,YAAoB;AAC5C,QAAM,CAAC,MAAM,OAAO,OAAO,WAAW,MAAM,KAAK,IAAI;AACrD,SAAO,MAAM,IAAI,KAAK,MAAM,QAAQ,GAAG;AAAA;",
  "names": []
}
